# Assignment 1
## Part 1 - The 2021 Puzzle

***State Space:*** Set of all states where the 25 tiles can be arranged on a 5x5 board <br><br>
***Initial State:*** Starting state of each of the 25 tiles arranged in a 5x5 board (initial board configuration) <br><br>
***Goal State:*** State of the 25 tile board where all tiles in consecutive ascending order (canonical board configuration)  you<br><br>
***Successor Function:*** Function that will account for the current state of the board returns a set of possible moves that can be done to the board given the contraints (can move rows 1-5 left or right, can move columns 1-5 up or down, can move outer ring clockwise or counterclockwise, can move inner ring clockwise or counterclockwise) <br><br>
***Edge Weights:*** Excluding our heuristic, each move has a value of 1. <br><br>
***Search Algorithm:*** A*
<br><br>
***Heuristic Function:***<br>For this problem, since any singular tile on the board can only move in the primary 4 directions (up, down, left, right) I decided to use the cummulative Manhattan distance of all of the tiles as my heuristic function since that would be considered an admissible heursitic when moves can only happen in those primary 4 directions. For each successor state, I determined the individual Manhattan distance for each tile compared to its "optimal end state" positioning and then summed up all of the individual Manhattan distances to get a total "board" cost. <br><br>
***Brief solution description:*** <br> My solution begins by initializing an empty fringe (will use heapq module to create a priority queue for the fringe) and tracking visited board states by using a dictionary and initially populating it with the initial board state. The starting elements are then inserted into the fringe, which include the manhattan distance cost of the initial board, the initial board itself, the current cost (representing # of moves / edge weights and initialized as 0), and the current path taken + the most recent move. After looping through all of the possible successors of the current state of the board (move row 1-5 L or R, move column 1-5 U or D, move outer or inner ring clockwise or counterclockwise), the algorithm first checks if the successor is a goal state if the successor is in a canonical configuration (tiles in order ascending). If it is, it will return the final path taken to get to that state. If not, it adds that state to the dict of visited states and calculates the total manhattan cost of the board. The heuristic value is then updated (total manhattan + current cost + 1) and pushed to the priority queue, which will continue to iterate until a goal state is found.<br><br>
***Problems, Assumptions, Decisions, etc.:***<br> The largest problem/assumption I had was the structure of the board as a tuple, specifically as it involved rotating the board. One route I considered was to turn the board into a 2d array for manipulation then turn it back into a 1d tuple prior to returning a solution, but I ended up staying true to the original tuple structure and maniuplating the board as it was. To my knowledge I believe tuples are generally more efficient that lists, which is why I decided to stick with keeping the board as a tuple. Another aspect I had to think about was the heuristic option. Since we've discussed a similar problem in class, Manhattan distance and # of misplaced tiles came to my mind as heuristics. After some testing, manhattan seemed to stand out as the best performer. Additionally, after some testing/research I decided to store visited states for this part and other parts as a dictionary instead of a list for more efficient processing. <br><br>
***Additional Questions:***<br> <br> *In this problem, what is the branching factor of the search tree?*<br>
The branching factor of the search tree is a static value of 24. 5 rows moved left + 5 rows moved right + 5 columns moved up + 5 columns moved down + 2 outer ring movements + 2 inner ring movements = 24<br><br>
*If the solution can be reached in 7 moves, about how many states would we need to explore before we found it if we used BFS instead of A* search?* <br>
With a branching factor of 24 and a depth of 7, we would have to explore roughly 24^7 states if we used BFS = ~4.5 billion states


## Part 2 - Road Trip

***State Space:*** Set of all cities listed <br><br>
***Initial State:*** The designated starting city <br><br>
***Goal State:*** Reaching the designated ending city <br><br>
***Successor Function:*** Function that will account for the current city and return a set of possible cities able to be visited from the current city based on defined contraints <br><br>
***Edge Weights:*** Dependent on the cost function selected for minimization (segments, distance, time, delivery time). Euclidean distance used as a heuristic <br><br>
***Search Algorithm:*** A*
<br><br>
***Heuristic Function:***<br>For this problem, since we had the coordinates of each city I decided to use the Euclidean distance between cities as my heuristic function. Since Euclidean distance can never overestimate the distance between two points, especially with something like a road where numerous twists and turns can be found, I knew that it would be admissible for this case. <br><br>
***Brief solution description:*** <br> My solution begins by initializing an empty fringe (will use heapq module to create a priority queue for the fringe) and tracking visited cities by using a dictionary. All of the various cost function values I needed to kkeep track of are initialized at 0. The starting elements are then inserted into the fringe, which include all of our cost function values, the route, and our heuristic value. The algorithm first checks if the lowest value in the fringe is a goal state (ending city). If it is, it will return the final path taken, the total # of segments, the total # of miles, the regular time, and the delivery time. If not, it adds that state to the dict of visited states and records the value of the cost function at the current city. For each successor, the 5 different cost function values are calculated and added to the current values and put into the fringe, along with the specific cost function value we are looking to minimize. If the algorithm comes across a visited city but it is now a more optimal path than before, it will be removed from the visited cities and repushed into the fringe with its updated cost function value. Priority queue will then continue to pop out the successor with the lowest specific cost function we want to minimize until goal state is reached.<br><br>
***Problems, Assumptions, Decisions, etc.:***<br> One major assumption I had to make was when calculating the time and delivery cost functions, euclidean distance needs to be divided by some speed estimation in order to properly calculate. Originally, I had researched that the max speed limit in the US was 80 mph and had used that in order to ensure never overestimating, but after looking through other peoples estimated solutions in the Q&A, I realized that 80 mph might have been reducing time too drastically. So I decided to calculate the max speed limit of the road segments file and use that, which ended up being 65. Changing the speed value helped the accuracy of my time and delivery time estimations dramatically. Additionally, if I came across a city that was not in the city gps file, I determined the heuristic value to be 0 in these cases. <br><br>


## Part 3 - Choosing Teams

***State Space:*** Set of all grouping combinations <br><br>
***Initial State:*** An initial grouping - randomized <br><br>
***Goal State:*** Grouping with the lowest total cost (time spending grading by instructors) <br><br>
***Successor Function:*** Function that will return all the possible combinations of groupings <br><br>
***Edge Weights:*** N/A (no heuristic either) <br><br>
***Search Algorithm:*** Random Search
<br><br>
***Brief solution description:*** <br> I struggled with determining a specific algorithm to use and settled upon something of a random search. I didn't believe a heuristic would be needed in this case. One of the major issues I ran into was being able to return the set of ALL possible groupings (successors). I knew that this would be cost intensive, but I was unable to come up with a formulation to return groupings with groups of sizes 1, 2, and 3. As a replacement, I was able to create random groupings of 3's and 2's and then used those to come up with a random successor that I tested in the script. The total cost for each grouping was calculated using the total # of teams, the preferred team size for each student, the preferred team members of each student, and the unwanted team members for each student, all multiplied by their specific costs. The solver function will take in a random grouping as its initialization and calculate its total cost. Then another random grouping order where teams are only size 3 is compared with a random grouping order where teams are only size 2, and the option with the lowest cost of these two moves forward for comparison under the condition that the groupings had not been "visited" yet. If this option has a cost function lower than any other cost function seen yet, the solution is yielded. The function will then continuously select random groupings and loop through this conditional until time expires.<br><br>
***Problems, Assumptions, Decisions, etc.:***<br> The major problem I had was create a solid list of successors. I was unable to determine a way to list all of the possible groupings for teams of sizes 1,2, and 3. Additionally, I knew this route would be very time intensive anyway as the test cases got larger. I generally expected that more optimal groupings will have more groups of 3 (and maybe 2) rather than 1 just due to the pure cost of having more teams (5 min extra per team). So I was able to figure out a way to return groupings with 3 team members only and groupings with 2 team members only, and use randomized outputs from these two functions as my smaller set of possible "successors" even though they arent necessarily the comprehneisve successor list. Outputting only 2 randomized groupings at a time rather than calculating all possible successors then choosing from that list definitely appeared to help from a time efficiency perspective as I got results relatively quickly, but I am unfortunately pretty certain that my current randomized search will not necessarily get the most optimal groupings in some cases. I had some general thoughts about maybe possibly implementing some kind of gradient descent algorithm after taking an initial random group, but was unable to implement it. <br><br>
